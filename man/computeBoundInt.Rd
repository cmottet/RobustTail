% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimizationFunctions.R
\name{computeBoundInt}
\alias{computeBoundInt}
\title{computeBoundInt}
\usage{
computeBoundInt(H, mu, sigma, lambda, direction = c("max", "min"))
}
\arguments{
\item{H}{: the function defined in program  (EC.19)}

\item{mu}{: an ordered vector containing a lower and upper bound of the first order moment in program  (EC.19)}

\item{sigma}{: an ordered vector containing a lower and upper bound ofo the second order moment  in program  (EC.19)}

\item{lambda}{:  a scalar giving the limit value of the ratio H(x)/x^2 when x goes to infinity}

\item{direction}{: a string either "\emph{min}" or "\emph{max}" identifying the type of wether program (5)
should be a min or a max program. Default is "max"}
}
\value{
a list containing the optimal objective value \emph{bound} and distribution function \emph{P} of program  (EC.19). In particular, P is a list
 containing point p = (p1, p2) masses and supports points x =(x1,x2).
}
\description{
This function returns the optimal objective value and solution of program  (EC.19) in the case when nu := 1,
and when the feasbile region is restricted to distribution functions with at most two point supports.
}
\examples{
####
#### Finding a the optimal probability measure (p,x) to the problem
####
#### max P(X > c)
#### s.t. sum(p)  = 1
####      1 <= sum(px) <= 2
####      2 <= sum(px^2) <= 3
####
#### where c is some real number. The solution to the  problem
####
#### max P(X > c)
#### s.t. sum(p)  = 1
####      sum(px) = 1
####      sum(px^2) = 2
#### is known (see Theorem 3.3 of Bertsimas and Popescu). Therefore, the optimal objective value
#### of the program with ineqality constraints should be an upper bound to the problem
#### with equality constraints.

# Function and parameters for the integral of the objective
c <- qexp(0.9)
H <- function(x) as.numeric(c <= x)
mu <- c(1,2)
sigma <- c(2,3)
lambda <- 0

output <- computeBoundInt(H,mu, sigma, lambda)

# Check that the bound is larger (because we increase the feasible set) than the analytical solution in Bertsimas
sigma0 <- 2 ; mu0 <- 1
CMsquare <- (sigma0- mu0^2)/mu0^2
delta <-  c/mu0-1

data.frame(Algorithm = output$bound, Analytical = CMsquare/(CMsquare + delta^2))

# Check that the output is feasible
with(output$P, data.frame(lowerMomentBound = c(1, mu[1], sigma[1]), moments = c(sum(p),sum(p*x), sum(p*x^2)), upperMomentBound = c(1, mu[2], sigma[2]) ))
}

