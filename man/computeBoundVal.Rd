% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimizationFunctions.R
\name{computeBoundVal}
\alias{computeBoundVal}
\title{computeBoundVal}
\usage{
computeBoundVal(H, mu, sigma, lambda, direction = c("max", "min"))
}
\arguments{
\item{H}{: the function H(x) defined in program (5)}

\item{mu}{:  the first order moment value in program (5)}

\item{sigma}{: the second order moment value in program (5)}

\item{lambda}{:  a scalar giving the limit value of the ratio H(x)/x^2 when x goes to infinity}

\item{direction}{: a string either "\emph{min}" or "\emph{max}" identifying the type of wether program (5)
should be a min or a max program. Default is "max"}
}
\value{
a list containing the optimal objective value \emph{bound} and distribution function \emph{P} of program (5). In particular, P is a list
 containing point p = (p1, p2) masses and supports points x =(x1,x2).
}
\description{
This function returns the optimal objective value and solution of program (5) in the case
when nu := 1, and when the feasbile region is restricted to distribution functions with at most two point supports.
}
\examples{
####
#### We wish to solve
####
#### max P(X > c)
#### s.t. sum(p)  = 1
####      sum(px) = 1
####      sum(px^2) = 2
####
#### for some value c. We point out that the solution to this problem is known (see Theorem 3.3 of Bertsimas and Popescu),
###

# Function and parameters for the integral of the objective
c <- qexp(0.9)
H <- function(x) as.numeric(x >= c)
mu <- 1
sigma <- 2
lambda <- 0

output <- computeBoundVal(H,mu, sigma, lambda)

# Check that the bound matches the analytical solution in Bertsimas
CMsquare <- (sigma- mu^2)/mu^2
delta <- c/mu-1

data.frame(Algorithm = output$bound, Analytical = CMsquare/(CMsquare + delta^2))

# Check that the output is feasible
with(output$P, data.frame(moments = c(sum(p),sum(p*x), sum(p*x^2)), truth = c(1,mu,sigma) ))
}

